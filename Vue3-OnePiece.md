​	Hello,大家好!今天晚上由我给大家主讲Vue3的一些新特性,主要想起到一些抛砖引玉的作用.在2020年的9月19日，万众期待的Vue3终于发布了正式版，经过将近一年半的时间,经过不断的更新维护,Vue3已经趋于稳定,并且是可预见的一个趋势,社区也变得更加的完善,包括我们常用的element组件也有对应的vue3版本elementplus.

​	首先呢,今晚我会大概分为4个主题来进行阐述,跟大家讲下一些Vue的原理和实际中Vue3开发的模式.

第一个部分是Vue内部的响应式原理的变化,底层的响应式原理机制从Object.defineProperty变成了Proxy这个ES6推出的Api来实现,正因为底层的这个变化,有些Api也就没必要存在了,例如Vue.set,Vue.delete这两个Api

第二个部分跟大家讲下可能是Vue最重要的变化,组合式Api英文叫compositionApi,这是我们外部可见的最大变化,并且会改变我们以往书写Vue文件的格式,这也是Vue3最重要的特性.

第三个部分在讲第二个部分的时候顺带讲下Vue3其他的一些新特性.

第四个部分会跟大家说点题外话,关于我自己看文档和源码的小经验.

​	在此期间如果有任何疑惑的话,欢迎随时打断我,我会尽自己全力给大家分享下我的见解.

接下来我们进入到第一个部分

## 响应式原理的变化.

​	首先和大家说下这个Api Object.defineProperty,当我们定义一个属性的时候,我们可以通过字面量的形式,比如a.b=3这样我们就给a这个对象赋值为一个键名为b,键值为3的属性,这是最通常的做法,同时我们还有另一种定义属性的方法,那就是Object.defineProperty,第一个参数是针对的对象,第二个是键名,第三个是一个配置对象,如果你用value属性返回b的值的话,其实和前面没有太大区别,除了一个是可枚举一个是不可枚举,还要一种方法返回值就是用get 和set函数返回.响应式是什么意思呢,在你获取一个值或者修改一个值的时候,Vue这个框架内部对其实现和这个值相关的修改或者页面上的更新.所以就需要在get和set函数,因为在获取和修改值的同时,Vue可以做些什么.

​	我们可以看出Vue这个响应式针对的是属性.所以就会有缺点就是他只能劫持到对已定义属性的获取或者是修改,也就是get和set这两个函数,还有就是不能监听到对象新增属性和通过数组已有下标改变数组.

​	为什么没办法监听对象新增属性呢,我们来看一张图,这张是Vue的生命周期图,我们写在Data选项或者Computed选项里面的数据是图中的BeforeCreated和Created之间由Vue内部进行响应式处理,也就是图中写的init jnjecttions和reactivity 初始化注入和响应式处理,在实例初始化时遍历data所有的property，并使用Object.defineProperty把这些属性全部转为getter/setter存取器来监听属性的查和改.

​	首先要明白一个前提条件,就是第一次可以使用this是在created钩子触发时,也就是Vue组件实例生成的时候,当我们想修改或者增加属性肯定要使用this对吧,可是响应式处理是在created之前,所以你在后面添加新的属性都是默认没有经过响应式处理的,,所以说我们要想属性是响应式的就一定要提前定义出来给个空值,或者你就只能使用Vue.set Vue.delete这两个Vue曝露出来的api.

​	第二讲下我觉得有意思的点,没办法通过下标更新数组,说实话以前有点理所当然的接受了这个设定,但是如果和对象一比,为啥都是属性,数组就没办法通过已有键名进行更新呢,在vue的issue里面尤玉溪进行了解答,是性能问题.因为刚刚讲的以上的诸多数点,导致Vue的一些更新机制,比如数组只能通过Vue内部重写的其他方法更新,或者直接重写覆盖数组,对象只能通过重写更新.或者是修改已有属性,或者是通过Vue.set,Vue.delete这两个api,虽然说记忆住这些特点并不是很难的事,但是总归有点逊,就很弱.

​	党在十三大报告指出:“我们现阶段所面临的主要矛盾，是人民日益增长的物质文化需要同落后的社会生产之间的矛盾”,这个Object.defineProperty有点局限的Api明显就和我们这些开发者产生了矛盾.因此,Vue3的时候,响应式原理就改变成用Proxy 这个ES6新出的api来实现.

​	首先我们来看下MDN的定义哈, Proxy对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属 性查找、赋值、枚举、函数调用等）

​	其次我们看下写法,就是new一个proxy对象,然后target指代的是目标对象,handle是拦截器的意思,为什么要用proxy呢,我们直接在target上操作不行吗,之所以弄出个proxy是因为我们对foo上面做的任何事都会作用到target身上,并且每一步都可以被拦截下来然后我们再做些自己想做的什么,这个拦截器一共可以拦截到13种基本操作,首先我来讲四个最基本的,我们CRUD工程师最常做的增删改查

Create Retrieve Update Delete

​	这样讲一圈其实还是有点不明显,因为都是些概念的东西.Linux祖师爷同时也是GIt祖师爷曾经说过这么一段经典的话,Talk is cheap SHow me the Code

```js
let data = {
      name: '张三',
    }
let vue={}
Object.defineProperty(vue, 'name', {
      configurable:true,
      get() {
        console.log('读取vue的name属性 执行响应式处理');
        return data.name
      },
      set(value) {
        console.log('修改vue的name属性 执行响应式处理');
        data.name = value
      }
    })
```

​	我带大家来看下这些代码哈,这个data对象类似我们写Vue文件里面的data选项,Vue呢就是Vue了,然后在组件初始化的时候,Vue内部就会把data里面的这些属性转换成getter和setter.其实就是去监听这些属性的查跟改,然后这个响应式处理的阶段只发生在生命周期的BeforeCreat和Created之间.这样的话我们就可以看见一个简易版的响应式数据,这个执行完之后,每当你获取和修改这个属性的值的时候,都会去执行你在内部定义的方法,Vue2就是通过这个Api来实现收集依赖和当依赖改变时触发响应式更新.比如我们新添加一个属性叫age,vue.age=20 是不触发任何东西的,同样删除也是.



​	我们接下里来看下Proxy的例子哈

```js
let data = {
    name: '张三',
    age: 20
  }

let vue = new Proxy(data, {
  get(target, propName) {
    console.log(`读取vue的${propName}属性`);
    return target[propName]
  },
  set(target, propName, value) {
    console.log(`增加或修改vue的${propName}属性`);
    target[propName] = value
  },
  deleteProperty(target, propName) {
    console.log(`删除vue的${propName}属性`);
    return delete target[propName]
}
})
```

​	我们在vue这个代理对象上搞的任何操作都会反应到data这个目标对象上,同时还会触发内部的响应式处理.我们来简单试下这个例子,

​	通过以上的例子和说明就是Vue的响应式原理底层实现机制的变化.接下来我们来进入第二个环节 

## 组合式api

​	刚刚讲的是底层原理的改变,现在讲下我们实际上会用到的改变,Vue3解决的痛点.相信大家肯定都接触过写的很长的Vue文件,当我们在做需求迭代的时候,有时候花最多时间,是搞明白别人写的这一些代码逻辑是什么,这些东西往往非常分散,同一个逻辑里面的代码,有的在data,有的在methods,有的是computed,有的在生命周期钩子里面,大家看下这两张图哈,左边是我在网上找到的,右边是官网的实例,相同的颜色代表是同一块的逻辑,相信大家应该都会有既视感.我们在维护某一个逻辑的时候,需要不断跳来跳去,这给我们的后期维护和更新迭代带来了很大的麻烦.当你一些代码不用时也很容易出现漏删的现象.我们现在所看的这个叫optionApi也就是选项api,分成了data,computed等一个个选项.为了解决逻辑分散,关注点分散的弊端.这个时候组合式Api就出现了.



​	组合式api顾名思义就是把原先分散在各处的逻辑组合起来在一个地方书写.vue3提供了一个新选项叫做setup();

`	setup()` 方法是在 `beforeCreate()` 生命周期函数之前执行的函数；任何使用this的选项都可以写在setup里面去组合使用.

​	点开vue2.vue文件 

​	首先呢Vue会遍历data里面的数据进行响应式处理,然后就是处理computed的数据,这时候也许需要用到data里面的数据,所以需要this,然后再接下来就是methods watch 生命钩子这些,之前这些选项都分开写,所以要把这些data computed method 挂载vue实例上,然后通过this去间接访问,当我们把这些东西都写在setup函数里面的时候,并不需要this这个vue实例来做中间商,所以一切使用this的选项都可以写在setup里面去组合使用.

​	我快速的跟大家介绍下,setup里面到底干了些什么. 

​	setup(props,contexs)  setup就是用来替代data computed methods 和生命周期这些选项的,setup就是自己定义的响应式数据,因为我们会通过this去调用props,并且通常用computed来返回一份props进行使用,所以第一个参数是props,来供里面的computed或者method等等之类使用.后面也是个配置对象,不讲太细,暂时跳过哈.

第二就是setup替代掉data选项的,之前我们都是直接写在data选项里面然后vue自动的帮我们实现响应式,现在需要我们自立自强了,vue曝露了两个函数供我们使用,一个叫reactive函数,来定义引用类型的响应式变量,reactive顾名思义响应嘛,另外一个叫ref函数,他是reactive reference的缩写 取引用的前三个字母来命名的,这个我们可以跟之前vue2常用的ref联系起来,但是又是很不同的.简单概括下就是它可以用来定义基本数据类型和引用数据类型的变量,但是在修改值的时候,需要通过value属性去修改.

第三就是computed函数,跟computed一样,不仅仅可以设置get也可以设置set,记忆的点就是它接收一个对象,可以是一个函数,或者是一个里面有get和set的对象.

第四就是watch,比较有意思的是这次vue提供了两个函数来替代watch选项.一个叫watch函数另一个叫watchEffect函数,比较有意思的是这两个函数的返回值可以终止掉这个watch,就像settimeout之类的 它们两个函数之间也是有点区别,暂且不表哈.

第五就是methods,所有的函数都可以直接定义在setup里面

第六就是模板引用 你需要直接手动定义模板引用来使用

第七就是生命周期函数

总结一句话就是 任何使用this的都可以写在setup里面

相信大家被我这么一套组合拳肯定都晕了,抛开这些概念.让我们来体验下vue3开发的样子.

## SetUP组件

vue2 ==> vue3

首先让我们看下页面,我们想实现一个很简单的小功能,一个计数器,还有一个学生信息的展示.让我们回到代码中来,看下Vue2和Vue3的区别,首先先对比template这个标签

经过简单的对比我们可以看出,这两个不能说是一模一样,只能说是完全一致.在template方面vue3的改动很小,我们基本不需要做出什么改动,你在vue2该怎么写页面就这么写页面.然后看下vue2的代码,就是data computed methods watch 这些简单的选项,vue2 vue3最大的不同是,之前我们都写在分别的选项里面,现在我们需要写在一个setup函数里面,并且需要返回出来供template使用.而且这些函数都需要手动进行引入.这就是最大的区别.





## 题外话

​    我刚开始也蛮喜欢看别人Vue的技术博客,但是其实事实上很多博客好点的是照搬官方文档的内容,差的就开始乱扯,很容易误导你.作为官方文档,vue其实是算是做的很不错的,尤其是英文版的,不仅通俗易懂,而且几乎挑不出什么毛病出来.	

​	当你觉得文档说的怪怪的,不妨你可以打开英文文档在旁边对照,很多时候都会觉得豁然开朗,因为虽然开发这个框架的作者尤玉溪同志是国人,但是官方文档的语言版本其实还是英文,中文版和其他非英语语言版本一样,其实是把英语版的翻译下来,而且翻译有时候还追求有点原教旨主义,为了不添油加醋的表达,有时候的表述会略显奇怪.并且因为我们母语是中文,所以看中文的时候也会速度太快,容易遗漏很多东西.

​    通过熟读文档,我也给vue官方文档提交了几个合并请求,虽然有的有点水,但是其实文档也不是百分百权威的,我通过自己的测验和查看vue源码就发现了些文档的错误.因此我也水到了vue文档贡献榜的13名.现在其他的新特性Vue3 setup语法糖刚出来也不是很久,应该还有很多小bug等待大家去挖掘.

  总结就是Vue的官方文档真的做的非常好,强烈安利给大家.

  谢谢大家今晚的与会,如果有问题的话欢迎提出来.

